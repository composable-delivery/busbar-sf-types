/**
 * GitHub Action (Node) to create/update a rollup issue when type generation finds:
 * - missing overlays (missing_overlays.json)
 * - uncategorized types (missing_categories.json or missing_uncategorized.json)
 *
 * This script is designed to be used with:
 * - actions/github-script (not required), or
 * - a composite action step using `node .github/actions/typegen-issues/index.js`
 *
 * INPUTS (env vars are easiest from workflow):
 * - GITHUB_TOKEN (required)
 * - GITHUB_REPOSITORY (required) e.g. "kantext-dev/busbar-sf-types"
 * - GITHUB_RUN_ID (optional)
 * - GITHUB_SHA (optional)
 * - GITHUB_REF_NAME (optional)
 *
 * Optional config (env):
 * - TYPEGEN_ISSUE_TITLE_PREFIX (default: "Typegen report")
 * - TYPEGEN_ISSUE_LABELS (default: "typegen,generation")
 * - TYPEGEN_ISSUE_ASSIGNEES (default: "")
 * - TYPEGEN_REPORT_DIR (default: ".")
 * - TYPEGEN_MAX_ITEMS_PER_SECTION (default: "200")
 * - TYPEGEN_CLOSE_WHEN_CLEAN (default: "true")
 *
 * Versioning:
 * - This action creates one rollup issue per @salesforce/types version.
 * - It attempts to determine the version via:
 *   1) TYPEGEN_SALESFORCE_TYPES_VERSION env var (preferred)
 *   2) .typegen-reports/salesforce_types_version.txt (or TYPEGEN_REPORT_DIR equivalent)
 *   3) package-lock.json (when present)
 *
 * Report file conventions:
 * - missing_overlays.json: JSON array of type names missing overlays
 * - missing_categories.json: JSON array of type names not categorized (preferred)
 * - missing_uncategorized.json: JSON array of type names not categorized (fallback)
 *
 * Behavior:
 * - If no findings:
 *   - optionally closes existing open rollup issue for this version (TYPEGEN_CLOSE_WHEN_CLEAN=true), else exits no-op.
 * - If findings:
 *   - searches for an OPEN issue for this version; updates if found, else creates.
 */

const fs = require("fs");
const path = require("path");

// ------------------------- Minimal GitHub REST client -------------------------

async function ghFetch(
  url,
  { token, method = "GET", headers = {}, body } = {},
) {
  if (!token) throw new Error("Missing GITHUB_TOKEN");
  const res = await fetch(url, {
    method,
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28",
      "User-Agent": "busbar-sf-types/typegen-issues",
      ...headers,
    },
    body: body ? JSON.stringify(body) : undefined,
  });
  const text = await res.text();
  let json = null;
  try {
    json = text ? JSON.parse(text) : null;
  } catch {
    // keep raw text
  }
  if (!res.ok) {
    const msg = json?.message || text || `HTTP ${res.status}`;
    throw new Error(`GitHub API error ${res.status}: ${msg}`);
  }
  return json;
}

function repoParts() {
  const repo = process.env.GITHUB_REPOSITORY;
  if (!repo || !repo.includes("/"))
    throw new Error("Missing/invalid GITHUB_REPOSITORY");
  const [owner, name] = repo.split("/", 2);
  return { owner, repo: name };
}

function getenv(name, fallback = "") {
  const v = process.env[name];
  return v == null || v === "" ? fallback : v;
}

function parseCsvEnv(name, fallback = "") {
  const raw = getenv(name, fallback).trim();
  if (!raw) return [];
  return raw
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);
}

function safeReadJsonArray(filePath) {
  try {
    if (!fs.existsSync(filePath)) return null;
    const raw = fs.readFileSync(filePath, "utf8");
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return null;
    return parsed.map(String);
  } catch {
    return null;
  }
}

function dedupeSorted(list) {
  const set = new Set(list);
  return Array.from(set).sort((a, b) => a.localeCompare(b));
}

function chunk(list, n) {
  const out = [];
  for (let i = 0; i < list.length; i += n) out.push(list.slice(i, i + n));
  return out;
}

function nowIso() {
  return new Date().toISOString();
}

function buildIssueTitle(prefix, salesforceTypesVersion) {
  // One rollup issue per @salesforce/types version.
  const v =
    salesforceTypesVersion && String(salesforceTypesVersion).trim()
      ? String(salesforceTypesVersion).trim()
      : "unknown";
  return `${prefix}: @salesforce/types ${v} - missing overlays / uncategorized types`;
}

function buildIssueBody({
  overlaysMissing,
  uncategorized,
  maxItemsPerSection,
  runUrl,
  sha,
  refName,
}) {
  const header = [
    `Generated by CI at ${nowIso()}.`,
    "",
    runUrl ? `- Run: ${runUrl}` : null,
    sha ? `- Commit: \`${sha}\`` : null,
    refName ? `- Ref: \`${refName}\`` : null,
  ]
    .filter(Boolean)
    .join("\n");

  const marker = "<!-- busbar-sf-types:typegen-rollup -->";

  const summaryLines = [
    "## Summary",
    "",
    `- Missing overlays: **${overlaysMissing.length}**`,
    `- Uncategorized types: **${uncategorized.length}**`,
    "",
  ];

  const section = (title, items, guidance, checkboxPrefix) => {
    const limited = items.slice(0, maxItemsPerSection);
    const truncated = items.length > limited.length;

    const lines = [`## ${title}`, ""];

    if (guidance) {
      lines.push(guidance.trim(), "");
    }

    if (limited.length === 0) {
      lines.push("_None._", "");
      return lines.join("\n");
    }

    lines.push("### Items", "");
    for (const name of limited) {
      // Use GitHub task list items for triage
      lines.push(`- [ ] ${checkboxPrefix}${name}`);
    }
    if (truncated) {
      lines.push(
        "",
        `_(Truncated: showing first ${limited.length} of ${items.length}.)_`,
      );
    }
    lines.push("");
    return lines.join("\n");
  };

  const overlaysGuidance = [
    "These types are missing entries in `sf-typegen/overlays.toml`.",
    "Add overlays for docs and any `schemars`-related annotations you need.",
  ].join("\n");

  const catsGuidance = [
    "These types were not assigned to a category/module during generation.",
    "Update `sf-typegen/src/categories.rs` (or categorization logic) so they land in the right feature-gated module.",
  ].join("\n");

  const overlaysSection = section(
    "Missing Overlays",
    overlaysMissing,
    overlaysGuidance,
    "",
  );

  const catsSection = section(
    "Uncategorized Types",
    uncategorized,
    catsGuidance,
    "",
  );

  const footer = [
    "## Notes",
    "",
    "- This is a rollup issue. Fix items by updating categorization rules and/or overlays, then regenerate types.",
    "- Once the next CI run is clean (no missing overlays/categorization), this issue may be auto-closed (configurable).",
    "",
  ].join("\n");

  return [
    marker,
    header,
    "",
    ...summaryLines,
    overlaysSection,
    catsSection,
    footer,
  ].join("\n");
}

// ------------------------------ GitHub helpers -------------------------------

async function listOpenIssuesByTitle({ token, owner, repo, title }) {
  // Search issues via REST: list issues and filter by title exact match.
  // (GitHub search API requires special query; list endpoint is simpler and sufficient for a single title.)
  const perPage = 100;
  let page = 1;
  const matches = [];

  while (page < 10) {
    const url = `https://api.github.com/repos/${owner}/${repo}/issues?state=open&per_page=${perPage}&page=${page}`;
    const data = await ghFetch(url, { token });
    if (!Array.isArray(data) || data.length === 0) break;
    for (const issue of data) {
      // pull requests also appear here; skip PRs
      if (issue.pull_request) continue;
      if (issue.title === title) matches.push(issue);
    }
    if (data.length < perPage) break;
    page += 1;
  }

  return matches;
}

async function createIssue({
  token,
  owner,
  repo,
  title,
  body,
  labels,
  assignees,
}) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues`;
  return await ghFetch(url, {
    token,
    method: "POST",
    body: {
      title,
      body,
      labels: labels.length ? labels : undefined,
      assignees: assignees.length ? assignees : undefined,
    },
  });
}

async function updateIssue({ token, owner, repo, issueNumber, body, labels }) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}`;
  return await ghFetch(url, {
    token,
    method: "PATCH",
    body: {
      body,
      labels: labels.length ? labels : undefined,
    },
  });
}

async function closeIssue({ token, owner, repo, issueNumber }) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}`;
  return await ghFetch(url, {
    token,
    method: "PATCH",
    body: { state: "closed" },
  });
}

// ------------------------------- Main logic ----------------------------------

async function main() {
  const token = getenv("GITHUB_TOKEN");
  const { owner, repo } = repoParts();

  const reportDir = getenv("TYPEGEN_REPORT_DIR", ".");
  const titlePrefix = getenv("TYPEGEN_ISSUE_TITLE_PREFIX", "Typegen report");

  const labels = parseCsvEnv("TYPEGEN_ISSUE_LABELS", "typegen,generation");
  const assignees = parseCsvEnv("TYPEGEN_ISSUE_ASSIGNEES", "");

  const maxItemsPerSection = parseInt(
    getenv("TYPEGEN_MAX_ITEMS_PER_SECTION", "200"),
    10,
  );
  const closeWhenClean =
    getenv("TYPEGEN_CLOSE_WHEN_CLEAN", "true").toLowerCase() === "true";

  const overlaysPath = path.join(reportDir, "missing_overlays.json");
  const missingOverlays = safeReadJsonArray(overlaysPath) || [];

  const missingCatsPath1 = path.join(reportDir, "missing_categories.json");
  const missingCatsPath2 = path.join(reportDir, "missing_uncategorized.json");
  const missingCategories =
    safeReadJsonArray(missingCatsPath1) ||
    safeReadJsonArray(missingCatsPath2) ||
    [];

  const overlaysMissing = dedupeSorted(missingOverlays);
  const uncategorized = dedupeSorted(missingCategories);

  const hasFindings = overlaysMissing.length > 0 || uncategorized.length > 0;

  // Determine @salesforce/types version (one rollup issue per version)
  const salesforceTypesVersion = (() => {
    const explicit = getenv("TYPEGEN_SALESFORCE_TYPES_VERSION", "").trim();
    if (explicit) return explicit;

    // Prefer a small text file written by generation, if present
    // (written by ./scripts/generate.sh into TYPEGEN_REPORT_DIR)
    const versionTxtPath = path.join(reportDir, "salesforce_types_version.txt");
    try {
      if (fs.existsSync(versionTxtPath)) {
        const v = fs.readFileSync(versionTxtPath, "utf8").trim();
        if (v) return v;
      }
    } catch {
      // ignore
    }

    // Fallback: parse package-lock.json if present
    try {
      const lockPath = path.join(process.cwd(), "package-lock.json");
      if (!fs.existsSync(lockPath)) return "unknown";
      const lock = JSON.parse(fs.readFileSync(lockPath, "utf8"));
      const v =
        lock?.packages?.["node_modules/@salesforce/types"]?.version ||
        lock?.dependencies?.["@salesforce/types"]?.version ||
        "";
      return v ? String(v).trim() : "unknown";
    } catch {
      return "unknown";
    }
  })();

  const title = buildIssueTitle(titlePrefix, salesforceTypesVersion);

  const runId = getenv("GITHUB_RUN_ID", "");
  const runUrl =
    runId && owner && repo
      ? `https://github.com/${owner}/${repo}/actions/runs/${runId}`
      : null;

  const sha = getenv("GITHUB_SHA", "");
  const refName = getenv("GITHUB_REF_NAME", "");

  const body = buildIssueBody({
    overlaysMissing,
    uncategorized,
    maxItemsPerSection,
    runUrl,
    sha,
    refName,
  });

  const existing = await listOpenIssuesByTitle({ token, owner, repo, title });

  if (!hasFindings) {
    console.log(
      "No typegen findings detected (no missing overlays/categorization lists).",
    );
    if (existing.length > 0 && closeWhenClean) {
      // Close all matching issues for this version (should normally be 1).
      for (const issue of existing) {
        console.log(`Closing rollup issue #${issue.number} (clean run).`);
        await closeIssue({ token, owner, repo, issueNumber: issue.number });
      }
    }
    return;
  }

  if (existing.length > 0) {
    // Update the first, close any extras (shouldn't happen, but keep tidy).
    const primary = existing[0];
    console.log(`Updating existing rollup issue #${primary.number}`);
    await updateIssue({
      token,
      owner,
      repo,
      issueNumber: primary.number,
      body,
      labels,
    });

    for (const extra of existing.slice(1)) {
      console.log(`Closing extra rollup issue #${extra.number} (duplicate).`);
      await closeIssue({ token, owner, repo, issueNumber: extra.number });
    }
    return;
  }

  console.log("Creating new rollup issue.");
  const created = await createIssue({
    token,
    owner,
    repo,
    title,
    body,
    labels,
    assignees,
  });
  console.log(`Created rollup issue #${created.number}: ${created.html_url}`);
}

// Run
main().catch((err) => {
  console.error(err?.stack || String(err));
  process.exit(1);
});
